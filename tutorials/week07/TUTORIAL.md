Week 7 Tutorial Questions
=========================
Work through these questions and make sure you understand what is going on in each example. We will start with a complete solution in ex01 that introduces two concepts, and then work on more complex examples that build upon this knowledge. If you have any questions about the material, please raise them in the tutorial session. 

Ex01 - Examples with Solution 
--------------------

Consider the [ex01 starter code](./starter/ex01) which has two complete examples, an example using convar's to allow two threads to synchronize behaviour and using futures to be able to undertake some work while an asyncronous operation is in progress. 

#### Ex01 - Convars

In [main_convar.cpp](./starter/ex01/main_convar.cpp) we use two threads to do some work in parallel, one generates data, the other computes a fibonacci sequence sum based on this number (so this could take a long amount of time). 

This is a simplistic example while also grounded in reality. We may have data being generated by one thread, and actions being executed by another. And the actions could take a different time to complete. So we decouple the two processes. 

We are using a [conditional variable](https://en.cppreference.com/w/cpp/thread/condition_variable).  Notice, the `convar` uses mechanism of `waiting` and `notifying`. Here we want one thread (the one that produces data) to notify the other when data is available. The other thing to consider is the `predicate` in `cv.wait(lk, []{return ready;});` the `return ready` here is evaluated when the thread checks should be released from the wait.

Questions to reflect on:

* What are the data structures used between threads, what role do the threads have? 
* What is CPU usage of this process? (hint, use top / htop)
* What value would you expect to see printed? 
* Notice we are using a  `unique_lock` on the mutex, why?
* How do we guarantee the `processSamples` runs immediately after new data is generated. 
* What is the convar checking? what two conditions are met? 

#### Ex01 - Futures

In [main_futures.cpp](./starter/ex01/main_futures.cpp) we show two threads (the main itself and another thread) doing some work in parallel. We kick of the thread `t` tied to `fibonaci` function and  use the concept of `promise` that will in the `future` return a value. This enables us to undertake work while the other thread is running and occasionally wait for the  status of the `future` to be finished. 

This is a simplistic example while also grounded in reality. We may have a thread waiting for an asynchronous task to be complete, a task that could take some unspecified amount of time. We need to undertake some actions in the meantime, until that task is complete, we can occasionally check on the progress of that task.

In contrast to the video on canvas on futures and promises, here we use a lambda function which let's us assign a return value to the promise. 

Questions to reflect on:

* What data types are used in the template of the promise and future?
* What is the role of the `wait_for` and checking `std::future_status::` 
* if we commented out the block that check fot these value, would the code still block?



Ex02 - Convars
--------------------

Consider the [ex02 starter code](./starter/ex02). We embed the `data`   `mutex` and `convar` in a `struct` called `Data` within namespace `pfms`. The use of namespace is recommended by the C+ coding standard we are following. The class `Sensor` contains `generateData` functionality and `Analysis` class has`processSamples` . The main connects the two classes by passing the struct `data` to both classes.  

Compile and run the code

TASK:

* Change operating directly on mutex with `lock` method to using a `unique_lock`

* Guarantee the `processSamples` runs immediately after new data is generated. Use a [conditional variable](https://en.cppreference.com/w/cpp/thread/condition_variable).  
  The `convar` uses mechanism of `waiting` and `notifying`. Here we want one thread (the one that produces data) to notify the other when data is available. The other thing to consider is the `predicate` in `cv.wait(lk, []{return ready;});` the `return ready` here is evaluated when the thread checks should be released from the wait. What would we be checking?

Ex03 - Threading Example
--------------------

Consider the [ex03 starter code](./starter/ex03). We have been provided with the source code of a sensor (radar), with a blocking call function [getData](./starter/ex03/radar.h), thus rendering the main blocked until data is available.  We are required to find the closest target from 3 radars.

Complete the following:
* Change the Radar class, so the thread of execution is inside the radar via the [start](./starter/ex02/radar.h) member function (the class will run now with a separate thread generating data
* Create 3 instances of the radar class and run the corresponding threads

Now create the Data Processing class that would find the closest target
* What do we need to pass to this class

Implement the following
* Find the closest target from all 3 radars every 50ms. How could we guarantee this occurs?
* Find the closest target from a radar whenever that sensor provides new data
* Find the closest target from a history of 2s of data asynchronously without impeding the other two operations

